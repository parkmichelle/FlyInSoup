<html>

  <head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
    <script src="https://d3js.org/d3-selection.v1.min.js"></script>
    <script src="https://d3js.org/d3-drag.v1.min.js"></script>
  </head>

  <body>
    <svg id='vis'></svg>
    <input type="text" id="searchbox" 
      placeholder="Search for restaurants..">

    <label class="switch">
      <input id="showNulls" type="checkbox">
      <span class="slider round"></span>
      <div>Show restaurants with no score</div>
    </label>

    <div>Circle A: </div><div id="textA">120</div>
    <input type="range" min="1" max="240" id="nRadiusA">

    <div>Circle B: </div><div id="textB">120</div>
    <input type="range" min="1" max="240" id="nRadiusB">


    

    <script>
      /*
       * Commented out, for when we want to get cursor position upon click
      function printMousePos(event) {
        [x, y] = [event.clientX, event.clientY];
        console.log("x: ", x, ", y: ", y);
      }

      document.addEventListener("click", printMousePos);
      */
      
      // Constants
      //const SPOTLIGHT_COLOR = "rgba(198, 45, 205, 0.6)";
      const INTERSECTION_COLOR = 'purple';
      const SPOTLIGHT_COLOR = "rgb(143, 166, 203, .3)";
      const DEFAULT_SPOTLIGHT_RADIUS = 120;
      const RADIUS_BUF = 3;
      const NAMES = ['a', 'b'];
      const DEFAULT_SPOTLIGHT_A = {
        name: "HONG KONG RESTAURANT",
        grade: "Pass",
        score: 94,
        lat: 37.418561,
        lng: -122.132842,
        address: "3691 EL CAMINO REAL ,PALO ALTO, CA 94306"
      };
      const DEFAULT_SPOTLIGHT_B = {
        name: "LA BAGUETTE",
        grade: "Pass",
        score: 70,
        lat: 37.44509,
        lng: -122.17126,
        address: "170 STANFORD SHOPPING CENTER ,PALO ALTO, CA 94304"
      };

      function Point(x, y) {
        this.x = x;
        this.y = y;
      }

      function Circle(centerXY, r) {
        this.centerXY = centerXY;
        this.r = r;
      }

      var intersection = new Set();

      // Set up size
      var mapWidth = 1000; var mapHeight = 750;

      // Set up projection that the map is using 
      var scale = 190000;
      var projection = d3.geoMercator()
                         .center([-122.061578, 37.385532])
                         .scale(scale)
                         .translate([mapWidth / 2, mapHeight / 2]);

      // This is the mapping between <longitude, latitude> position 
      // to <x, y> pixel position on the map
      // projection is a function and it has an inverse:
      // projection([lon, lat]) returns [x, y]
      // projection.invert([x, y]) returns [lon, lat]
      // Add an SVG element to the DOM
      var svg = d3.select('body').append('svg')
                  .attr('width', mapWidth)
                  .attr('height', mapHeight);

      // Add SVG map at correct size, assuming map is saved in a 
      // subdirectory called `data`
      svg.append('image')
         .attr('width', mapWidth)
         .attr('height', mapHeight)
         .attr('xlink:href', 'media/map.svg');

      var allData;
      var spotlightA;
      var spotlightB;
      var circleA;
      var circleB;
      // Read in data
      d3.csv('data/data.csv', function(d) {
        return {
          name: d.Name,
          grade: d.Grade,
          score: +d.Score,
          lat: +d.Latitude,
          lng: +d.Longitude,
          address: d.Adress
        };
      }).then(function(data) {
        allData = data; // save data into var

        spotlightA = drawSpotlight(DEFAULT_SPOTLIGHT_A.lng, DEFAULT_SPOTLIGHT_A.lat, DEFAULT_SPOTLIGHT_RADIUS, allData, NAMES[0]);
        spotlightB = drawSpotlight(DEFAULT_SPOTLIGHT_B.lng, DEFAULT_SPOTLIGHT_B.lat, DEFAULT_SPOTLIGHT_RADIUS, allData, NAMES[1]);

        drawPoints(getIntersection(allData, spotlightA, spotlightB), 'purple', 'intersection');        
        addScale();

        d3.select("#nRadiusA").on("input", function() {
          update(+this.value, NAMES[0]);
        });
        d3.select("#nRadiusB").on("input", function() {
          update(+this.value, NAMES[1]);
        });


      });

      // Updates the circle size and text based on radius
      function update(nRadius, id) {
        // adjust the text on the range slider
        d3.select("#nRadius-value").text(nRadius);
        d3.select("#text" + id).text(nRadius);

        // update the circle radius
        d3.select('#' + id).attr('r', nRadius);

        var inter = getIntersection(allData, spotlightA, spotlightB);
        drawPoints(inter, 'purple', 'intersection');

      }


        function getIntersection(data, spotlightA, spotlightB) {
         var intersection = data.filter(function(d) {
           return inCircle(spotlightA, lngLatToXY(d.lng, d.lat)) 
             && inCircle(spotlightB, lngLatToXY(d.lng, d.lat));
         });
          return intersection;
      }

      // Calculates whether a point lies within a circle, using Euclidean distance
      function inCircle(circle, point) {
        var x1 = circle.attr('cx');
        var x2 = point.x;
 
        var y1 = circle.attr('cy');
        var y2 = point.y;

        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) < (circle.attr('r') - RADIUS_BUF);
      }

      // Converts lng, lat pair to x, y on map
      // Could optimize by using this to add property to data upon read in
      // instead of calling every time we draw point
      function lngLatToXY(lng, lat) {
        [x, y] = projection([lng, lat]);
        return new Point(x, y);
      }

      // Displays the colorscale
      // Src: https://github.com/d3/d3-scale-chromatic/blob/master/README.md#interpolateRainbow
      function addScale() {

      var colorScale = d3.scaleSequential(d3.interpolateRdYlGn).domain([0, mapWidth]);

        var bars = svg.selectAll(".bars")
          .data(d3.range(mapWidth), function(d) { return d; })
          .enter().append("rect")
          .attr("class", "bars")
          .attr("x", function(d, i) { return i; })
          .attr("y", 0)
          .attr("height", 50)
          .attr("width", 1)
          .style("fill", function(d, i ) { return colorScale(d); })
    
      }

      // Draws a circle of radius r at the given lng, lat projected onto map
      function drawSpotlight(lng, lat, r, data, id) {
        var xyPos = lngLatToXY(lng, lat);
        var circle = svg.append('circle');

        circle.attr('r', r)
              .attr('cx', xyPos.x)
              .attr('cy', xyPos.y)
              .attr('z-index', 0)
              .attr('id', id)
              .style('fill', SPOTLIGHT_COLOR)
              .call(d3.drag().on('drag', redraw));

        return circle;
      }

      // Draws circles on each data point in the selected color- if color is "default", color encode pass/fail score
      function drawPoints(data, color, id) {
        let points = svg.selectAll('#' + id);
        let updatedPoints = points.data(data, d => d === undefined ? null : d.name);
        let enterSelection = updatedPoints.enter();
        let newPoints = enterSelection.append('circle')
                          .attr('id', id)
                          .attr('r', 4)
                          .attr('cx', function(d) { 
                            return lngLatToXY(d.lng, d.lat).x; 
                           })
                          .attr('cy', function(d) { 
                            return lngLatToXY(d.lng, d.lat).y; 
                           })
                          .style('fill', function(d) {
                            return color;
                            //return intersection.has(d)? INTERSECTION_COLOR : d3.interpolateRdYlGn(d.score/100);
                          })
                          .attr('opacity', 1)
                          .on('mouseover', function(d) {
                              svg.append('text')
                                 .attr('x', lngLatToXY(d.lng, d.lat).x + 10)
                                 .attr('y', lngLatToXY(d.lng, d.lat).y + 5)
                                 .text(d.name + ' ' + d.score)
                              })
                          .on('mouseout', function(d) {
                            svg.selectAll('text').remove()
                          });
          updatedPoints.exit().remove();
      }

      d3.select('#searchbox').on('keyup', function() {
        var inputText = document.getElementById('searchbox').value.toUpperCase();
        const matches = allData.filter(d => d.name.toUpperCase().includes(inputText));
        spotlightA = drawSpotlight(DEFAULT_SPOTLIGHT_A.lng, DEFAULT_SPOTLIGHT_A.lat, DEFAULT_SPOTLIGHT_RADIUS, allData, NAMES[0]);
        spotlightB = drawSpotlight(DEFAULT_SPOTLIGHT_B.lng, DEFAULT_SPOTLIGHT_B.lat, DEFAULT_SPOTLIGHT_RADIUS, allData, NAMES[1]);
        
        drawPoints(matches, 'purple', 'intersection'); // redraw circles
      });

      // Callback for dragging- need to learn how to pass in data
      // Need to pass in the data sets and other svg so we can re-calculate and plot intersection
      function redraw() {
        d3.select(this)
          .attr('cx', d3.event.x)
          .attr('cy', d3.event.y);

        var inter = getIntersection(allData, spotlightA, spotlightB);
        drawPoints(inter, 'purple', 'intersection');
      }
    </script>

  </body>

<html/>
